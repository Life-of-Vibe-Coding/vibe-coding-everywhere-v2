import type { IServerConfig } from "@/core/types";
import { Platform } from "react-native";
import Constants from "expo-constants";

/**
 * Connection mode for the mobile app.
 *   - "direct"     : Direct URL connection (localhost, LAN, etc.)
 *   - "cloudflare" : Cloudflare Tunnel — base URL is tunnel URL; proxy uses X-Target-Port / _targetPort
 */
type ConnectionMode = "direct" | "cloudflare";

function getConnectionMode(): ConnectionMode {
  const mode =
    typeof process !== "undefined" ? (process.env?.EXPO_PUBLIC_CONNECTION_MODE ?? "").trim().toLowerCase() : "";
  if (mode === "direct" || mode === "cloudflare") {
    return mode as ConnectionMode;
  }
  return "direct";
}

/**
 * Get the tunnel proxy port (used for X-Target-Port / _targetPort routing).
 */
function getTunnelProxyPort(): number {
  const port =
    typeof process !== "undefined"
      ? (process.env?.EXPO_PUBLIC_TUNNEL_PROXY_PORT ?? "").trim()
      : "";
  return port ? parseInt(port, 10) || 9443 : 9443;
}

function parseEnvHost(value: string): string | null {
  if (!value) return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  try {
    const parsed = new URL(trimmed.startsWith("http") ? trimmed : `http://${trimmed}`);
    return parsed.hostname || null;
  } catch {
    return null;
  }
}

function parseHostFromRuntimeMetadata(): string | null {
  if (typeof process === "undefined") return null;
  const rawCandidates = [
    (Constants as { manifest?: unknown })?.manifest && (Constants as { manifest?: Record<string, unknown> }).manifest?.debuggerHost,
    (Constants as { manifest?: unknown })?.manifest && (Constants as { manifest?: Record<string, unknown> }).manifest?.hostUri,
    (Constants as { expoConfig?: unknown })?.expoConfig && (Constants as { expoConfig?: Record<string, unknown> }).expoConfig?.hostUri,
    (Constants as { expoGoConfig?: unknown })?.expoGoConfig && (Constants as { expoGoConfig?: Record<string, unknown> }).expoGoConfig?.hostUri,
  ];

  for (const candidate of rawCandidates) {
    const host = parseEnvHost(typeof candidate === "string" ? candidate : "");
    if (host) return host;
  }
  return null;
}

let localBaseUrlRewriteWarned = false;
let localBaseUrlWarned = false;

function getServerHostOverride(): string | null {
  if (typeof process === "undefined") return null;
  const explicitHost =
    parseEnvHost(process.env?.EXPO_PUBLIC_SERVER_HOST ?? "") ||
    parseEnvHost(process.env?.EXPO_PUBLIC_SERVER_IP ?? "") ||
    parseEnvHost(process.env?.EXPO_PUBLIC_HOST_IP ?? "");
  if (explicitHost) return explicitHost;
  const runtimeHost = parseHostFromRuntimeMetadata();
  if (runtimeHost) return runtimeHost;
  if (Platform.OS === "android") return "10.0.2.2";
  return null;
}

function normalizeBaseUrl(rawUrl: string): string {
  const base = rawUrl.trim();
  if (!base) return base;
  try {
    const parsed = new URL(base);
    const host = parsed.hostname.toLowerCase();
    if (host !== "localhost" && host !== "127.0.0.1") {
      return base.replace(/\/$/, "");
    }

    const replacementHost = getServerHostOverride();
    if (!replacementHost) {
      if (Platform.OS !== "web") {
        if (!localBaseUrlWarned) {
          localBaseUrlWarned = true;
          console.warn(
            "[ServerConfig] Base URL still points to localhost on mobile. Set EXPO_PUBLIC_SERVER_HOST (or EXPO_PUBLIC_SERVER_IP) to a reachable host."
          );
        }
      }
      return base.replace(/\/$/, "");
    }

    if (replacementHost === host) return base.replace(/\/$/, "");
    parsed.hostname = replacementHost;
    const normalized = parsed.toString().replace(/\/$/, "");
    if (!localBaseUrlRewriteWarned) {
      localBaseUrlRewriteWarned = true;
      console.log(
        `[ServerConfig] Rewrote base host from ${host} to ${replacementHost} for ${Platform.OS} runtime.`
      );
    }
    return normalized;
  } catch {
    return base.replace(/\/$/, "");
  }
}

/**
 * Default server config (env-based). Inject IServerConfig in tests or for different backends.
 */
function getBaseUrlFromEnv(): string {
  const url =
    typeof process !== "undefined" && process.env?.EXPO_PUBLIC_SERVER_URL
      ? process.env.EXPO_PUBLIC_SERVER_URL
      : "http://localhost:3456";
  return normalizeBaseUrl(url);
}

export function createDefaultServerConfig(): IServerConfig {
  const connectionMode = getConnectionMode();

  return {
    getBaseUrl: getBaseUrlFromEnv,
    resolvePreviewUrl(previewUrl: string): string {
      try {
        const base = getBaseUrlFromEnv();
        const baseParsed = new URL(base);
        const parsed = new URL(previewUrl);

        // ── Cloudflare (tunnel) mode: preview URLs route through the proxy ──
        // The reverse proxy (e.g. behind Cloudflare Tunnel) uses X-Target-Port
        // to forward to the right port. For WebView we use query param _targetPort.
        if (connectionMode === "cloudflare") {
          const isPreviewLocalhost =
            parsed.hostname === "localhost" || parsed.hostname === "127.0.0.1";
          const basePort = baseParsed.port || (baseParsed.protocol === "https:" ? "443" : "80");
          const previewPort = parsed.port || (parsed.protocol === "https:" ? "443" : "80");

          if (isPreviewLocalhost) {
            // Rewrite the URL to go through the proxy base URL (Cloudflare tunnel URL)
            const targetPort = previewPort !== basePort ? previewPort : basePort;
            const proxyUrl = new URL(base);
            proxyUrl.pathname = parsed.pathname || "/";
            proxyUrl.search = parsed.search || "";
            proxyUrl.hash = parsed.hash || "";

            if (targetPort !== basePort) {
              proxyUrl.searchParams.set("_targetPort", targetPort);
            }

            const resolved = proxyUrl.toString();
            if (__DEV__) {
              console.log(
                "[PreviewURL] resolvePreviewUrl (" +
                  connectionMode +
                  "): incoming=" +
                  previewUrl +
                  " | resolved=" +
                  resolved
              );
            }
            return resolved;
          }

          if (__DEV__) {
            console.log("[PreviewURL] resolvePreviewUrl (" + connectionMode + "): keep as-is | incoming=" + previewUrl);
          }
          return previewUrl;
        }

        // ── Direct mode ──
        const basePort = baseParsed.port || (baseParsed.protocol === "https:" ? "443" : "80");
        const previewPort = parsed.port || (parsed.protocol === "https:" ? "443" : "80");
        const isSameHost =
          parsed.hostname === "localhost" ||
          parsed.hostname === "127.0.0.1" ||
          parsed.hostname === baseParsed.hostname;
        const isSamePort = previewPort === basePort;
        if (isSameHost && isSamePort) {
          const pathname = (parsed.pathname || "/").replace(/^\//, "") || "index.html";
          const cleanUrl = `${base.replace(/\/$/, "")}/${pathname}${parsed.search || ""}${parsed.hash || ""}`;
          if (__DEV__) {
            console.log("[PreviewURL] resolvePreviewUrl: base=" + base + " | incoming=" + previewUrl + " | resolved=" + cleanUrl);
          }
          return cleanUrl;
        }
        // Different port: port-to-port — replace localhost with a host the device can reach.
        // When base is localhost, device cannot reach Mac; use EXPO_PUBLIC_PREVIEW_HOST if set.
        const isPreviewLocalhost = parsed.hostname === "localhost" || parsed.hostname === "127.0.0.1";
        if (isPreviewLocalhost && baseParsed.hostname) {
          const baseIsLocal = baseParsed.hostname === "localhost" || baseParsed.hostname === "127.0.0.1";
          const previewHostRaw = typeof process !== "undefined" ? (process.env.EXPO_PUBLIC_PREVIEW_HOST ?? "").trim() : "";
          let portToPortHost = baseParsed.hostname;
          if (baseIsLocal && previewHostRaw) {
            try {
              portToPortHost = new URL(previewHostRaw.startsWith("http") ? previewHostRaw : `http://${previewHostRaw}`).hostname;
            } catch {
              portToPortHost = previewHostRaw;
            }
          }
          const portSuffix = parsed.port ? `:${parsed.port}` : "";
          const rewritten = `${baseParsed.protocol}//${portToPortHost}${portSuffix}${parsed.pathname || "/"}${parsed.search || ""}${parsed.hash || ""}`;
          if (__DEV__) {
            console.log("[PreviewURL] resolvePreviewUrl: port-to-port | incoming=" + previewUrl + " | resolved=" + rewritten);
          }
          return rewritten;
        }
        if (__DEV__) {
          console.log("[PreviewURL] resolvePreviewUrl: keep as-is | incoming=" + previewUrl);
        }
        return previewUrl;
      } catch (e) {
        if (__DEV__) {
          console.log("[PreviewURL] resolvePreviewUrl: parse error, using as-is | incoming=" + previewUrl + " | error=" + String(e));
        }
        return previewUrl;
      }
    },
  };
}

/** Singleton default for app use when no DI container is used. */
let defaultInstance: IServerConfig | null = null;

export function getDefaultServerConfig(): IServerConfig {
  if (!defaultInstance) defaultInstance = createDefaultServerConfig();
  return defaultInstance;
}

/** Expose connection mode for UI components that need to adapt (e.g. UrlChoiceModal). */
export function getConnectionModeForUI(): ConnectionMode {
  return getConnectionMode();
}
