/**
 * Pi agent skills discovery and loading.
 *
 * Scans the skills/ folder for SKILL.md files, parses frontmatter,
 * and loads enabled skill content for prompt injection.
 */
import fs from "fs";
import path from "path";
import { projectRoot } from "../config/index.js";

const SKILL_FILE = "SKILL.md";
const ENABLED_FILE_PATH = path.join(projectRoot, "server", "skills-enabled.json");

/**
 * Skill category mapping. Maps skill directory name to a category.
 * Categories: Development, UI/UX, DevOps, Debug, Prompt
 */
const SKILL_CATEGORIES = {
  "fullstack-software-engineer": "Development",
  "react-native-animations": "Development",
  "refactor": "Development",
  "test-driven-development": "Development",
  "terminal-runner": "Development",
  "ui-ux-pro-max": "UI/UX",
  "enhance-prompt": "UI/UX",
  "git-advanced-workflows": "DevOps",
  "using-git-worktrees": "DevOps",
  "finishing-a-development-branch": "DevOps",
  "systematic-debugging": "Debug",
  "receiving-code-review": "Debug",
  "requesting-code-review": "Debug",
  "verification-before-completion": "Debug",
  "brainstorming": "Prompt",
  "dispatching-parallel-agents": "Prompt",
  "executing-plans": "Prompt",
  "subagent-driven-development": "Prompt",
  "using-superpowers": "Prompt",
  "writing-plans": "Prompt",
  "writing-skills": "Prompt",
};

function getSkillCategory(id) {
  return SKILL_CATEGORIES[id] || "Development";
}

/**
 * Parse YAML frontmatter from SKILL.md content.
 * Extracts name and description between first --- pair.
 * @param {string} content - Full file content
 * @returns {{ name?: string; description?: string }}
 */
function parseFrontmatter(content) {
  const match = content.match(/^---\s*\n([\s\S]*?)\n---/);
  if (!match) return {};

  const block = match[1];
  const nameMatch = block.match(/^name:\s*(.+)$/m);
  const descMatch = block.match(/^description:\s*(.+)$/m);

  const name = nameMatch?.[1]?.trim()?.replace(/^["']|["']$/g, "") ?? undefined;
  const description = descMatch?.[1]?.trim()?.replace(/^["']|["']$/g, "") ?? undefined;

  return { name, description };
}

/**
 * Discover all skills in the skills directory.
 * @param {string} skillsDir - Absolute path to skills/
 * @returns {{ skills: Array<{ id: string; name: string; description: string }> }}
 */
export function discoverSkills(skillsDir) {
  const skills = [];

  if (!skillsDir || !fs.existsSync(skillsDir)) {
    return { skills };
  }

  try {
    const entries = fs.readdirSync(skillsDir, { withFileTypes: true });
    for (const ent of entries) {
      if (!ent.isDirectory()) continue;

      const skillPath = path.join(skillsDir, ent.name);
      const skillFile = path.join(skillPath, SKILL_FILE);
      if (!fs.existsSync(skillFile) || !fs.statSync(skillFile).isFile()) continue;

      try {
        const content = fs.readFileSync(skillFile, "utf8");
        const { name, description } = parseFrontmatter(content);
        skills.push({
          id: ent.name,
          name: name ?? ent.name,
          description: description ?? "",
          category: getSkillCategory(ent.name),
        });
      } catch (err) {
        console.warn("[skills] Failed to parse", skillFile, err?.message);
      }
    }
  } catch (err) {
    console.warn("[skills] Failed to scan", skillsDir, err?.message);
  }

  return { skills };
}

/**
 * Get full skill content (SKILL.md) for a single skill by id or name.
 * First tries exact id (folder name), then falls back to matching by display name.
 * @param {string} id - Skill id (directory name) or name (from frontmatter)
 * @param {string} skillsDir - Absolute path to skills/
 * @returns {{ id: string; name: string; description: string; content: string; children: Array } | null}
 */
export function getSkillContent(id, skillsDir) {
  if (!skillsDir || !fs.existsSync(skillsDir) || !id || typeof id !== "string") {
    return null;
  }
  const skillRoot = path.resolve(skillsDir);
  const idClean = id.trim();
  let subdir = path.basename(idClean.replace(/[/\\]/g, ""));
  let skillPath = path.join(skillRoot, subdir, SKILL_FILE);

  if (!skillPath.startsWith(skillRoot) || !fs.existsSync(skillPath) || !fs.statSync(skillPath).isFile()) {
    const { skills } = discoverSkills(skillsDir);
    const match = skills.find(
      (s) =>
        s.id === idClean ||
        s.id === subdir ||
        s.name === idClean ||
        (s.name && s.name.toLowerCase() === idClean.toLowerCase()) ||
        (s.id && s.id.toLowerCase() === idClean.toLowerCase())
    );
    if (match) {
      subdir = match.id;
      skillPath = path.join(skillRoot, subdir, SKILL_FILE);
    }
  }

  if (!skillPath.startsWith(skillRoot) || !fs.existsSync(skillPath) || !fs.statSync(skillPath).isFile()) {
    return null;
  }

  try {
    const content = fs.readFileSync(skillPath, "utf8").trim();
    const { name, description } = parseFrontmatter(content);

    const skillDir = path.dirname(skillPath);
    const children = [];
    if (fs.existsSync(skillDir) && fs.statSync(skillDir).isDirectory()) {
      const entries = fs.readdirSync(skillDir, { withFileTypes: true });
      for (const ent of entries) {
        if (ent.name.startsWith(".")) continue;
        children.push({
          name: ent.name,
          type: ent.isDirectory() ? "directory" : "file",
        });
      }
      children.sort((a, b) => {
        if (a.type !== b.type) return a.type === "directory" ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    }

    return {
      id: subdir,
      name: name ?? subdir,
      description: description ?? "",
      content,
      children,
    };
  } catch (err) {
    console.warn("[skills] Failed to read", skillPath, err?.message);
    return null;
  }
}

/**
 * Get children of a subfolder within a skill. Used for expandable folder trees.
 * @param {string} skillId - Skill id (directory name)
 * @param {string} relativePath - Path relative to skill root, e.g. "data" or "data/stacks"
 * @param {string} skillsDir - Absolute path to skills/
 * @returns {{ children: Array<{ name: string; type: "directory" | "file" }> } | null}
 */
export function getSkillChildren(skillId, relativePath, skillsDir) {
  if (!skillsDir || !fs.existsSync(skillsDir) || !skillId || typeof skillId !== "string") {
    return null;
  }
  const skillRoot = path.resolve(skillsDir);
  const idClean = skillId.trim().replace(/[/\\]/g, "");
  const safePath = (relativePath || "")
    .split(/[/\\]+/)
    .filter((p) => p && p !== "." && p !== "..")
    .join(path.sep);
  const targetDir = path.join(skillRoot, idClean, safePath);

  if (!targetDir.startsWith(path.join(skillRoot, idClean)) || !fs.existsSync(targetDir) || !fs.statSync(targetDir).isDirectory()) {
    return null;
  }

  try {
    const children = [];
    const entries = fs.readdirSync(targetDir, { withFileTypes: true });
    for (const ent of entries) {
      if (ent.name.startsWith(".")) continue;
      children.push({
        name: ent.name,
        type: ent.isDirectory() ? "directory" : "file",
      });
    }
    children.sort((a, b) => {
      if (a.type !== b.type) return a.type === "directory" ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
    return { children };
  } catch (err) {
    console.warn("[skills] Failed to read children", targetDir, err?.message);
    return null;
  }
}

/**
 * Resolve agent directory (workspace .pi/agent first, then project .pi/agent).
 * Uses same logic as piRpcSession for auth; for skills we fall back to project .pi/agent if needed.
 * @param {string} workspaceCwd - Current workspace path
 * @param {string} projectRoot - Project root path
 * @returns {string | null}
 */
export function resolveAgentDir(workspaceCwd, projectRoot) {
  const workspaceAgentDir = path.join(workspaceCwd, ".pi", "agent");
  const workspaceAuthPath = path.join(workspaceAgentDir, "auth.json");
  const projectAgentDir = projectRoot ? path.join(projectRoot, ".pi", "agent") : null;

  if (fs.existsSync(workspaceAuthPath)) return workspaceAgentDir;
  if (projectAgentDir && fs.existsSync(path.join(projectAgentDir, "auth.json"))) return projectAgentDir;
  if (fs.existsSync(workspaceAgentDir)) return workspaceAgentDir;
  if (projectAgentDir && fs.existsSync(projectAgentDir)) return projectAgentDir;
  if (projectAgentDir) return projectAgentDir;

  return null;
}

/**
 * Get enabled skill IDs from persistence.
 * @param {string} agentDir - Resolved agent directory (ignored, stored globally now)
 * @returns {string[]}
 */
export function getEnabledIds(agentDir) {
  try {
    if (!fs.existsSync(ENABLED_FILE_PATH)) return [];
    const data = JSON.parse(fs.readFileSync(ENABLED_FILE_PATH, "utf8"));
    const ids = data?.enabledIds;
    const filtered = Array.isArray(ids) ? ids.filter((x) => typeof x === "string" && x) : [];
    return [...new Set(filtered)]; // Deduplicate to prevent same skill loading twice
  } catch (err) {
    console.warn("[skills] Failed to read", ENABLED_FILE_PATH, err?.message);
    return [];
  }
}

/**
 * Set enabled skill IDs in persistence.
 * @param {string} agentDir - Resolved agent directory (ignored, stored globally now)
 * @param {string[]} enabledIds - List of skill IDs to enable
 * @returns {{ ok: boolean; error?: string }}
 */
export function setEnabledIds(agentDir, enabledIds) {
  const normalized = Array.isArray(enabledIds)
    ? enabledIds.filter((x) => typeof x === "string" && x.trim())
    : [];

  try {
    fs.mkdirSync(path.dirname(ENABLED_FILE_PATH), { recursive: true });
    fs.writeFileSync(ENABLED_FILE_PATH, JSON.stringify({ enabledIds: normalized }, null, 2), "utf8");
    return { ok: true };
  } catch (err) {
    console.warn("[skills] Failed to write", ENABLED_FILE_PATH, err?.message);
    return { ok: false, error: err?.message ?? "Failed to save" };
  }
}

/**
 * Build a skill roster of ENABLED skills only. Agent sees only enabled skills.
 * When asked "what skills are you capable of", the agent lists only these.
 * @param {string} skillsDir - Absolute path to skills/
 * @param {string} agentDir - Resolved agent directory
 * @returns {string} Roster text to prepend, or "" if none enabled
 */
export function getSkillsRoster(skillsDir, agentDir) {
  const enabledIds = getEnabledIds(agentDir);
  if (enabledIds.length === 0) return "";

  const { skills } = discoverSkills(skillsDir);
  const enabledSkills = skills.filter((s) => enabledIds.includes(s.id));
  if (enabledSkills.length === 0) return "";

  const lines = enabledSkills.map((s) => `- ${s.name}: ${(s.description || "").slice(0, 120)}${s.description && s.description.length > 120 ? "â€¦" : ""}`);
  return (
    "[Your available skills are ONLY the following (enabled). When asked about your capabilities or skills, list ONLY these.]\n\n" +
    lines.join("\n") +
    "\n\n---\n\n"
  );
}

/**
 * Sync a folder with symlinks to only the enabled skills. Used for Pi --skill loading.
 * Creates targetDir/id -> skillsDir/id for each enabled skill that exists.
 * @param {string} skillsDir - Absolute path to skills/ (from /api/skills)
 * @param {string} agentDir - Resolved agent directory (for getEnabledIds)
 * @param {string} targetDir - Where to create symlinks, e.g. workspaceCwd/.pi/skills-enabled
 * @returns {string[]} Absolute paths to each enabled skill (for --skill flags)
 */
export function syncEnabledSkillsFolder(skillsDir, agentDir, targetDir) {
  const enabledIds = getEnabledIds(agentDir);
  if (enabledIds.length === 0) return [];

  const skillRoot = path.resolve(skillsDir);
  const paths = [];

  try {
    if (fs.existsSync(targetDir)) {
      const entries = fs.readdirSync(targetDir, { withFileTypes: true });
      for (const ent of entries) {
        if (!ent.name.startsWith(".")) {
          const p = path.join(targetDir, ent.name);
          try {
            fs.unlinkSync(p); // symlinks are removed with unlink
          } catch (_) { }
          try {
            fs.rmSync(p, { recursive: true, force: true });
          } catch (_) { }
        }
      }
    } else {
      fs.mkdirSync(targetDir, { recursive: true });
    }

    for (const id of enabledIds) {
      if (!id || typeof id !== "string") continue;
      const subdir = path.basename(id);
      const srcPath = path.join(skillRoot, subdir);
      const skillFile = path.join(srcPath, SKILL_FILE);
      if (!srcPath.startsWith(skillRoot) || !fs.existsSync(skillFile) || !fs.statSync(skillFile).isFile()) continue;

      const linkPath = path.join(targetDir, subdir);
      try {
        fs.symlinkSync(srcPath, linkPath, "dir");
      } catch (err) {
        console.warn("[skills] Failed to symlink", subdir, err?.message);
        continue;
      }
      paths.push(linkPath);
    }
  } catch (err) {
    console.warn("[skills] Failed to sync enabled-skills folder:", err?.message);
  }

  return paths;
}

/**
 * Load full SKILL.md content for enabled skills, for prompt injection.
 * Only loads skills that exist and are under skillsDir (security).
 * @param {string} skillsDir - Absolute path to skills/
 * @param {string} agentDir - Resolved agent directory
 * @returns {string} Combined skill content to prepend to prompt
 */
export function loadEnabledSkillsContent(skillsDir, agentDir) {
  const enabledIds = getEnabledIds(agentDir);
  if (enabledIds.length === 0) return "";

  const skillRoot = path.resolve(skillsDir);
  const parts = [];
  const seen = new Set(); // Avoid loading same skill twice if id appears in multiple forms

  for (const id of enabledIds) {
    if (!id || typeof id !== "string") continue;
    const subdir = path.basename(id);
    if (seen.has(subdir)) continue;
    seen.add(subdir);

    const skillPath = path.join(skillRoot, subdir, SKILL_FILE);

    if (!skillPath.startsWith(skillRoot)) continue;
    if (!fs.existsSync(skillPath) || !fs.statSync(skillPath).isFile()) continue;

    try {
      const content = fs.readFileSync(skillPath, "utf8").trim();
      if (content) parts.push(content);
    } catch (err) {
      console.warn("[skills] Failed to load", skillPath, err?.message);
    }
  }

  if (parts.length === 0) return "";

  return (
    "[Enabled skills - apply ONLY when the user's message clearly matches the skill's intended use (see each skill's 'When to use' / description). " +
    "For greetings, small talk, clarifications, or non-coding requests, respond normally without applying skill protocols. " +
    "Do NOT run skill procedures (e.g. Environment Detection) for simple greetings or off-topic messages.]\n\n" +
    parts.join("\n\n---\n\n") +
    "\n\n---\n\n"
  );
}
